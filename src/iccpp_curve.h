#ifndef iccpp_curve_H
#define iccpp_curve_H
//---------------------------------------------------------------------------------
//
//  LIBICC++  
//  Copyright Marco Oman 2015
//
// Distributed under the Boost Software License, Version 1.0. 
// (See accompanying file LICENSE_1_0.txt or copy at 
// http://www.boost.org/LICENSE_1_0.txt)
//
#include <vector>
#include "iccpp_function.h"

/**
    @file
    @brief This file some algorithms (curves, 1D Lut) defined by an ICC profile
*/
namespace iccpp
{
	inline double clip01(double x)
	{
		return (x < 0.0 ? 0.0 : (x > 1.0 ? 1.0 : x));
	}
	// 
	// These are functions generated by the loader
	//
	class icc_gamma_curve_t : public algo_t<double, double>
	{
	public:
		icc_gamma_curve_t(double gamma) : gamma_(gamma) {}
		double eval(const double &value) const override
		{
			return std::pow(value, gamma_);
		}
		virtual icc_gamma_curve_t *clone(void) const override
		{
			return new icc_gamma_curve_t(gamma_);
		}
	private:
		double gamma_;
	};

	class icc_curve_interpolated_t : public algo_t<double, double>
	{
	public:
		// add the way to move construct the vector
		// assume thre are at last 2 knots...
		icc_curve_interpolated_t(const std::vector<double> &knots) : knots_(knots)
		{
			step_ = 1.0 / (knots_.size() - 1);
		}
		double eval(const double &value) const override
		{
            int index = static_cast<int>(value / step_);
			if (index < 0)
				return *knots_.begin();
            else if (index + 1 == static_cast<int>(knots_.size()))
				return *knots_.rbegin();
			else
			{
				double dx = (value - step_ * index) / step_;
				return knots_[index] * (1.0 - dx) + dx * knots_[index + 1];
			}
		}
		virtual icc_curve_interpolated_t *clone(void) const override
		{
			return new icc_curve_interpolated_t(knots_);
		}
	private:
		std::vector<double> knots_; // should they be reference counted?
		double              step_;
	};

	class icc_curve_parametric_t : public algo_t<double, double>
	{
	public:
		icc_curve_parametric_t(double g,
			double a = 1.0,
			double b = 0.0,
			double c = 0.0,
			double d = 0.0,
			double e = 0.0,
			double f = 0.0) : g_(g), a_(a), b_(b), c_(c), d_(d), e_(e), f_(f) {}
		icc_curve_parametric_t *clone(void) const override
		{
			return new icc_curve_parametric_t(g_, a_, b_, c_, d_, e_, f_);
		}
		virtual double eval(const double &x) const override
		{
			if (x < d_)
				return clip01(c_ * x + f_);
			else
				return clip01(std::pow(a_ *x + b_, g_) + e_);
		}
	private:
		double g_;
		double a_;
		double b_;
		double c_;
		double d_;
		double e_;
		double f_;
	};

	template <int Outputs, int Inputs>
	using algo_vect_t = algo_t<vector_t<double, Outputs>, vector_t<double, Inputs>>;

	template <int Outputs, int Inputs>
	using function_vect_t = function_t<vector_t<double, Outputs>, vector_t<double, Inputs>>;

	template <int N>
	class icc_curve_t : public algo_vect_t<N, N>
	{
	public:
		icc_curve_t(const icc_curve_t<N> &rhs)
		{
			for (int i = 0; i < N; i++)
				algo_[i].reset(rhs.algo_[i]->clone());
		}
		icc_curve_t(algo_t<double, double> **algos)
		{
			for (int i = 0; i < N; i++)
				algo_[i].reset(algos[i]);
		}
		icc_curve_t<N> *clone(void) const
		{
			return new icc_curve_t<N>(*this);
		}
		vector_t<double, N> eval(const vector_t<double, N> &rhs) const override
		{
			vector_t<double, N> result;
			for (int i = 0; i < N; i++)
				result[i] = algo_[i]->eval(rhs[i]);
			LOG_PIXEL(__FUNCTION__, result);
			return result;
		}
	private:
		std::unique_ptr<algo_t<double, double>> algo_[N];
	};

	template <int Outputs, int Inputs>
	class icc_matrix_affine_t : public algo_vect_t<Outputs, Inputs>
	{
	public:
		typedef double line_t[Inputs + 1];
		icc_matrix_affine_t(void)
		{
			for (int i = 0; i < Outputs; i++)
				for (int j = 0; j < Inputs; j++)
					matrix_[i][j] = (i == j ? 1.0 : 0.0);
		}
		icc_matrix_affine_t(const line_t *matrix)
		{
            memcpy(matrix_, matrix, sizeof(matrix_));
		}
		double *operator[](int index) { return matrix_[index]; }
		icc_matrix_affine_t *clone(void) const override
		{
			return new icc_matrix_affine_t(matrix_);
		}
		virtual vector_t<double, Outputs> eval(const vector_t<double, Inputs> &x) const override
		{
			// TODO add clipping  [0,1] range
			vector_t<double, Outputs> result;
			for (int i = 0; i < Outputs; i++)
				result[i] = arithmetic_t<double, Inputs>::dot(x.data(), matrix_[i]) + matrix_[i][Inputs];
			LOG_PIXEL(__FUNCTION__, result);
		    return result;
		}
	private:
		double matrix_[Outputs][Inputs + 1];
	};

	template <int Outputs, int Inputs>
	class icc_matrix_linear_t : public algo_vect_t<Outputs, Inputs>
	{
	public:
		typedef double line_t[Inputs];
		icc_matrix_linear_t(void)
		{
			for (int i = 0; i < Outputs; i++)
				for (int j = 0; j < Inputs; j++)
					matrix_[i][j] = (i == j ? 1.0 : 0.0);
		}
		icc_matrix_linear_t(const line_t *matrix)
		{
            memcpy(matrix_, matrix, sizeof(matrix_));
		}
		double *operator[](int index) { return matrix_[index]; }
		icc_matrix_linear_t *clone(void) const override
		{
			return new icc_matrix_linear_t(matrix_);
		}
		virtual vector_t<double, Outputs> eval(const vector_t<double, Inputs> &x) const override
		{
			// TODO add clipping  [0,1] range
			vector_t<double, Outputs> result;
			for (int i = 0; i < Outputs; i++)
				result[i] = arithmetic_t<double, Inputs>::dot(x.data(), matrix_[Outputs]);
			LOG_PIXEL(__FUNCTION__, result);
			return result;
		}
	private:
		double matrix_[Outputs][Inputs];
	};


}

#endif
